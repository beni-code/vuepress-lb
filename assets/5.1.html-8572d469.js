const e=JSON.parse('{"key":"v-70bcfdec","path":"/PDFs/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/5.1.html","title":"5.1 子系统的启动和终止","lang":"zh-CN","frontmatter":{"icon":"edit","date":"2022-02-11T00:00:00.000Z","category":["计算机图形学"],"tag":["游戏引擎"],"description":"5.1 子系统的启动和终止 游戏引擎是一个复杂软件，由多个互相合作的子系统结合而成。当引擎启动时，必须依次配置及初始化每个子系统。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序。 例如，子系统B依赖于子系统A，那么在启动B之前，必须先启动A。各子系统的终止通常会采用反向次序，即先终止B，再终止A。 5.1.1 C++的静态初始化次序(是不可用的) 由于多数新式游戏引擎皆采用C++为编程语言，我们应考虑一下，C++原生的启动及终止语义是否可做启动及终止引擎子系统之用。在C++中，在调用程序进人点（main()或Windows下的WinMain())之前，全局对象及静态对象已被构建。然而，我们完全不可预知这些构造函数的调用次序[1]。在main()或winMain()结束返回之后，会调用全局对象及静态对象的析构函数，而这些函数的调用次序也是无法预知的。显而易见，此C++行为并不适合用来初始化及终止游戏引擎的子系统。实际上，这对任何含互相依赖全局对象的软件都不适合。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/vuepress-lb/PDFs/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84/5.1.html"}],["meta",{"property":"og:site_name","content":"Notes"}],["meta",{"property":"og:title","content":"5.1 子系统的启动和终止"}],["meta",{"property":"og:description","content":"5.1 子系统的启动和终止 游戏引擎是一个复杂软件，由多个互相合作的子系统结合而成。当引擎启动时，必须依次配置及初始化每个子系统。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序。 例如，子系统B依赖于子系统A，那么在启动B之前，必须先启动A。各子系统的终止通常会采用反向次序，即先终止B，再终止A。 5.1.1 C++的静态初始化次序(是不可用的) 由于多数新式游戏引擎皆采用C++为编程语言，我们应考虑一下，C++原生的启动及终止语义是否可做启动及终止引擎子系统之用。在C++中，在调用程序进人点（main()或Windows下的WinMain())之前，全局对象及静态对象已被构建。然而，我们完全不可预知这些构造函数的调用次序[1]。在main()或winMain()结束返回之后，会调用全局对象及静态对象的析构函数，而这些函数的调用次序也是无法预知的。显而易见，此C++行为并不适合用来初始化及终止游戏引擎的子系统。实际上，这对任何含互相依赖全局对象的软件都不适合。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-11T13:14:31.000Z"}],["meta",{"property":"article:tag","content":"游戏引擎"}],["meta",{"property":"article:published_time","content":"2022-02-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-11T13:14:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.1 子系统的启动和终止\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-02-11T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-11T13:14:31.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"5.1.1 C++的静态初始化次序(是不可用的)","slug":"_5-1-1-c-的静态初始化次序-是不可用的","link":"#_5-1-1-c-的静态初始化次序-是不可用的","children":[{"level":3,"title":"5.1.1.1 按需构建","slug":"_5-1-1-1-按需构建","link":"#_5-1-1-1-按需构建","children":[]}]},{"level":2,"title":"5.1.2 行之有效的简单方法","slug":"_5-1-2-行之有效的简单方法","link":"#_5-1-2-行之有效的简单方法","children":[]},{"level":2,"title":"5.1.3 一些实际引擎的例子","slug":"_5-1-3-一些实际引擎的例子","link":"#_5-1-3-一些实际引擎的例子","children":[{"level":3,"title":"5.1.3.1 OGRE","slug":"_5-1-3-1-ogre","link":"#_5-1-3-1-ogre","children":[]},{"level":3,"title":"5.1.3.2 顽皮狗的神秘海域系列和最后生还者","slug":"_5-1-3-2-顽皮狗的神秘海域系列和最后生还者","link":"#_5-1-3-2-顽皮狗的神秘海域系列和最后生还者","children":[]}]}],"git":{"createdTime":1676121271000,"updatedTime":1676121271000,"contributors":[{"name":"liben","email":"714376485@qq.com","commits":1}]},"readingTime":{"minutes":7.99,"words":2396},"filePathRelative":"PDFs/游戏引擎架构/5.1.md","localizedDate":"2022年2月11日","excerpt":"<h1> 5.1 子系统的启动和终止</h1>\\n<p>游戏引擎是一个复杂软件，由多个互相合作的子系统结合而成。当引擎启动时，必须依次配置及初始化每个子系统。各子系统间的相互依赖关系，隐含地定义了每个子系统所需的启动次序。</p>\\n<p>例如，子系统B依赖于子系统A，那么在启动B之前，必须先启动A。各子系统的终止通常会采用反向次序，即先终止B，再终止A。</p>\\n<h2> 5.1.1 C++的静态初始化次序(是不可用的)</h2>\\n<p>由于多数新式游戏引擎皆采用C++为编程语言，我们应考虑一下，C++原生的启动及终止语义是否可做启动及终止引擎子系统之用。在C++中，在调用程序进人点（main()或Windows下的WinMain())之前，全局对象及静态对象已被构建。然而，我们完全不可预知这些构造函数的调用次序<sup class=\\"footnote-ref\\"><a href=\\"#footnote1\\">[1]</a><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\"></a></sup><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\">。在main()或winMain()结束返回之后，会调用全局对象及静态对象的析构函数，而这些函数的调用次序也是无法预知的。显而易见，此C++行为并不适合用来初始化及终止游戏引擎的子系统。实际上，这对任何含互相依赖全局对象的软件都不适合。</a></p>","autoDesc":true}');export{e as data};
